                        ; --------------------------------------
                        ; zasm: assemble "monitor.asm"
                        ; date: 2023-11-15 16:06:29
                        ; --------------------------------------


                        ; defines
0000:                   PORT_MEMPAGE	.equ	0x00
0010:                   PORT_UART1		.equ	0x10
0018:                   PORT_UART2		.equ	0x18
                        ; variables
8000:                   PTR_INPUT		.equ	0x8000
8020:                   PTR_ARGV		.equ	0x8020 ; list of pointers to PTR_INPUT
8030:                   PTR_ARGC		.equ	0x8030
                        
                        
0000:                   .org 0x0000
0000:                   init:
0000: F3       [ 4]     	di
                        	; set upper ram page
                        	;ld a, 0x00
                        	;out (PORT_MEMPAGE), a
                        	; cpu init
0001: 31FFFF   [14]     	ld sp, 0xFFFF
0004: 3E00     [21]     	ld a, 0x00
0006: ED47     [30]     	ld i, a
0008: ED5E     [38]     	im 2
                        	; device init
000A: CDB703   [55]     	call uart_init
                        
                        	; clear memory
000D: 210080   [65]     	ld hl, 0x8000
0010:                   _init_loop:
0010: 36FF     [10]     	ld (hl), 0xFF
0012: 23       [16]     	inc hl
0013: 7C       [20]     	ld a, h
0014: FEFF     [27]     	cp 0xFF
0016: C21000   [37|37]  	jp nz, _init_loop
                        
                        	; jump to main
0019: C30001   [47]     	jp main
                        
                        
                        
001C: FFFFFFFF          .org 0x0100
0020: FF...             
0100:                   main:
0100: 210204   [10]     	ld hl, str_hello
0103: CDE003   [27]     	call uart1_puts
0106:                   _main_loop:
                        	; print promt
0106: 210B04   [10]     	ld hl, str_promt
0109: CDE003   [27]     	call uart1_puts
                        	; input buffer
010C: 210080   [37]     	ld hl, PTR_INPUT
                        	; pointer to argument
010F: 444D     [45]     	ld bc, hl
                        	; argc
0111: 3E00     [52]     	ld a, 0
0113: 323080   [65]     	ld (PTR_ARGC), a
0116:                   _main_loop_getc:
0116: CDEB03   [17]     	call uart1_getch
                        	; check if newline or space
0119: FE0D     [24]     	cp 0x0D
011B: 2830     [31|36]  	jr z, _main_newline
                        	; echo back
011D: CDD403   [48]     	call uart1_putc
                        	; check if space
0120: FE20     [55]     	cp ' '
0122: 2008     [62|67]  	jr nz, _main_loop_no_space
                        	; save memory location to argv pointer
0124: CD5B01   [79]     	call add_argv
                        	; save next location as start of new argument
0127: 444D     [87]     	ld bc, hl
0129: 03       [93]     	inc bc
                        	; save a 0 instead of a space
012A: 3E00     [100]    	ld a, 0
012C:                   _main_loop_no_space:
                        	; check if backspace
012C: FE08     [ 7]     	cp 0x08
012E: 2804     [14|19]  	jr z, _main_loop_backspace
                        	; not return: put into buffer
0130: 77       [21]     	ld (hl), a
0131: 23       [27]     	inc hl
0132: 18E2     [39]     	jr _main_loop_getc
0134:                   _main_loop_backspace:
0134: 3E00     [ 7]     	ld a, 0
0136: 77       [14]     	ld (hl), a
                        	; check if pointer at 0
0137: 110080   [24]     	ld de, PTR_INPUT
013A: ED52     [39]     	sbc hl, de
013C: 19       [50]     	add hl, de
013D: CA1601   [60|60]  	jp z, _main_loop_getc
                        	; if there are some chars, delete last one
0140: 2B       [66]     	dec hl
                        	; print space
0141: 3E20     [73]     	ld a, ' '
0143: CDD403   [90]     	call uart1_putc
0146: 3E08     [97]     	ld a, 0x08
0148: CDD403   [114]    	call uart1_putc
014B: 18C9     [126]    	jr _main_loop_getc
014D:                   _main_newline:
                        	; enter pressed
                        	; end buffer with terminating 0
014D: 3600     [10]     	ld (hl), 0x00
                        	; save last argument in argv list
014F: CD5B01   [27]     	call add_argv
                        	; parse command
0152: CDF503   [44]     	call uart1_newline
0155: CD7701   [61]     	call handle_cmd
                        	; print shell again
0158: C30601   [71]     	jp _main_loop
                        
                        
                        
                        ; add_argv
                        ;   add pointer in bc to argv list
015B:                   add_argv:
015B: D5       [11]     	push de
015C: E5       [22]     	push hl
                        	; get argc and multiply by 2
015D: 3A3080   [35]     	ld a, (PTR_ARGC)
0160: CB27     [43]     	sla a
0162: 1600     [50]     	ld d, 0
0164: 5F       [54]     	ld e, a
                        	; de is offset
0165: 212080   [64]     	ld hl, PTR_ARGV
0168: 19       [75]     	add hl, de
0169: 7123702B [101]    	ld (hl), bc
                        	; increment argc
016D: 3A3080   [114]    	ld a, (PTR_ARGC)
0170: 3C       [118]    	inc a
0171: 323080   [131]    	ld (PTR_ARGC), a
                        	; return
0174: E1       [141]    	pop hl
0175: D1       [151]    	pop de
0176: C9       [161]    	ret
                        
                        
                        
                        ; handle command string
                        ;   command string in argv
0177:                   handle_cmd:
                        	; check if input buffer zero
0177: 3A0080   [13]     	ld a, (PTR_INPUT)
017A: FE00     [20]     	cp 0
017C: C8       [25|31]  	ret z
                        	; get mnemonic id by comparing to list
017D: ED4B2080 [45]     	ld bc, (PTR_ARGV)
0181: 211604   [55]     	ld hl, lst_cmds_str_ptr
0184: CDA501   [72]     	call get_index
0187: FEFF     [79]     	cp 0xFF
0189: 2813     [86|91]  	jr z, _handle_cmd_error
                        	; get function pointer, index in a
018B: 21FB04   [96]     	ld hl, lst_cmds_ptr
018E: CDCC01   [113]    	call get_word_from_index
0191: E5       [124]    	push hl
                        	; save return address in stack for return
0192: CD9501   [141]    	call _handle_cmd_call_func
0195:                   _handle_cmd_call_func:
                        	; get pc address 0x0178
0195: E1       [10]     	pop hl
0196: 010800   [20]     	ld bc, 8
0199: 09       [31]     	add hl, bc
019A: E5       [42]     	push hl ; hl points to address after jp (hl)
                        	; call address in hl
019B: E1       [52]     	pop hl
019C: E9       [56]     	jp (hl)
019D: C9       [66]     	ret
019E:                   _handle_cmd_error:
019E: 210E04   [10]     	ld hl, str_error
01A1: CDE003   [27]     	call uart1_puts
01A4: C9       [37]     	ret
                        
                        
                        
                        ; pointer to string in bc
                        ; pointer to list of strings in hl
                        ; 
                        ;   compares command to first space to list of commands
01A5:                   get_index:
                        	; save start of string
01A5: 3E00     [ 7]     	ld a, 0
01A7: F5       [18]     	push af
01A8: 5059     [26]     	ld de, bc
01AA:                   _get_index_list_loop:
                        	; get pointer to string by index
01AA: 211604   [10]     	ld hl, lst_cmds_str_ptr
01AD: CDCC01   [27]     	call get_word_from_index ; gets pointer to string with index a
                        	; last index is zero
01B0: 010000   [37]     	ld bc, 0x0000
01B3: ED42     [52]     	sbc hl, bc
01B5: 09       [63]     	add hl, bc
01B6: 2810     [70|75]  	jr z, _get_index_not_found
                        	; get start of string, array pointer in hl
01B8: 424B     [78]     	ld bc, de
                        	; pointer to command_str[a] in hl
                        	; compare strcmp(command_str[a], str)
01BA: CDDF01   [95]     	call strcmp
                        	; check if strings were the same
01BD: FE01     [102]    	cp 1
01BF: 2805     [109|114]	jr z, _get_index_found
                        	; not equal: next index
01C1: F1       [119]    	pop af
01C2: 3C       [123]    	inc a
01C3: F5       [134]    	push af
                        	; index in a
01C4: 18E4     [146]    	jr _get_index_list_loop
01C6:                   _get_index_found:
01C6: F1       [10]     	pop af
01C7: C9       [20]     	ret
01C8:                   _get_index_not_found:
01C8: F1       [10]     	pop af
01C9: 3EFF     [17]     	ld a, 0xFF
01CB: C9       [27]     	ret
                        
                        
                        
                        ; get_word_from_index
                        ;   hl - pointer to start of list
                        ;    a - index of list of words
                        ;   Returns: hl - word at (hl + a*2)
01CC:                   get_word_from_index: ; hl = (hl+a*2)
01CC: F5       [11]     	push af
01CD: CB27     [19]     	sla a ; a=a*2
                        	; add a to hl
01CF: 85       [23]     	add a, l
01D0: 6F       [27]     	ld l, a
01D1: 8C       [31]     	adc a, h
01D2: 95       [35]     	sub l
01D3: 67       [39]     	ld h, a
                        	; get word from pointer
01D4: C5       [50]     	push bc
01D5: 444D     [58]     	ld bc, hl
01D7: 0A       [65]     	ld a, (bc)
01D8: 6F       [69]     	ld l, a
01D9: 03       [75]     	inc bc
01DA: 0A       [82]     	ld a, (bc)
01DB: 67       [86]     	ld h, a
01DC: C1       [96]     	pop bc
                        	; return
01DD: F1       [106]    	pop af
01DE: C9       [116]    	ret
                        
                        
                        
                        ; strcmp
                        ;   compare two strings
                        ;   hl - first string
                        ;   bc - second string
                        ;   returns a: 0 not equal, 1 equal
01DF:                   strcmp:
                        	; check if second string ends
01DF: 7E       [ 7]     	ld a, (hl)
01E0: FE00     [14]     	cp 0
01E2: 280F     [21|26]  	jr z, _strcmp_equal
                        	; check if first string ends
01E4: 0A       [28]     	ld a, (bc)
01E5: FE00     [35]     	cp 0
01E7: 280A     [42|47]  	jr z, _strcmp_equal
                        	; check if chars are the same
01E9: BE       [49]     	cp (hl)
01EA: 2004     [56|61]  	jr nz, _strcmp_not_equal
                        	; next char
01EC: 23       [62]     	inc hl
01ED: 03       [68]     	inc bc
01EE: 18EF     [80]     	jr strcmp
01F0:                   _strcmp_not_equal:
01F0: 3E00     [ 7]     	ld a, 0
01F2: C9       [17]     	ret
01F3:                   _strcmp_equal:
01F3: 3E01     [ 7]     	ld a, 1
01F5: C9       [17]     	ret
                        
                        
                        
                        ; command: print help
01F6:                   cmd_help:
01F6: 212102   [10]     	ld hl, str_cmd_help
01F9: CDE003   [27]     	call uart1_puts
                        	; index counter
01FC: 0600     [34]     	ld b, 0
01FE:                   _cmd_help_loop:
01FE: 78       [ 4]     	ld a, b
01FF: 211604   [14]     	ld hl, lst_cmds_str_ptr
0202: CDCC01   [31]     	call get_word_from_index
                        	; check if pointer is zero
0205: 110000   [41]     	ld de, 0x0000
0208: ED52     [56]     	sbc hl, de
020A: 19       [67]     	add hl, de
020B: C8       [72|78]  	ret z
                        	; print command name
020C: CDE003   [89]     	call uart1_puts
                        	; print space
020F: 3E20     [96]     	ld a, ' '
0211: CDD403   [113]    	call uart1_putc
0214: CDD403   [130]    	call uart1_putc
                        	; print description
0217: 23       [136]    	inc hl
0218: CDE003   [153]    	call uart1_puts
021B: CDF503   [170]    	call uart1_newline
                        	; next index
021E: 04       [174]    	inc b
021F: 18DD     [186]    	jr _cmd_help_loop
0221: 436F6D6D          str_cmd_help: .db "Commands:", 0x0D, 0x0A, 0x00
0225: 616E6473          
0229: 3A0D0A00          
                        
                        
                        
                        ; command: dump memory
                        ;   starting address in hl
                        ;   puts first argument in bc, second in de
022D:                   cmd_dump:
022D: 3A3080   [13]     	ld a, (PTR_ARGC)
0230: FE02     [20]     	cp 2
0232: 2014     [27|32]  	jr nz, _cmd_dump_error
                        	; get second argument
0234: 212080   [37]     	ld hl, PTR_ARGV
0237: 3E01     [44]     	ld a, 1
0239: CDCC01   [61]     	call get_word_from_index
                        	; convert string to hex word
023C: CD7A03   [78]     	call word_to_val
                        	; dump memory
023F: 6069     [86]     	ld hl, bc
0241: CD3E03   [103]    	call dump_mem
0244: CDF503   [120]    	call uart1_newline
0247: C9       [130]    	ret
0248:                   _cmd_dump_error
0248: 214F02   [10]     	ld hl, str_cmd_dump_help
024B: CDE003   [27]     	call uart1_puts
024E: C9       [37]     	ret
024F: 55736167          str_cmd_dump_help: .db "Usage: dump <start_addr>", 0x0D, 0x0A, "<start_addr> in hex", 0x0D, 0x0A, "example: dump 1000", 0x0D, 0x0A, 0x00
0253: 653A2064          
0257: 756D7020          
025B: 3C737461          
025F: 72745F61          
0263: 6464723E          
0267: 0D0A3C73          
026B: 74617274          
026F: 5F616464          
0273: 723E2069          
0277: 6E206865          
027B: 780D0A65          
027F: 78616D70          
0283: 6C653A20          
0287: 64756D70          
028B: 20313030          
028F: 300D0A00          
                        
                        
                        
                        ; command: write memory
                        ;   argv in PTR_ARGV
                        ;   argc in PTR_ARGC
0293:                   cmd_mset:
0293: 3A3080   [13]     	ld a, (PTR_ARGC)
0296: FE02     [20]     	cp 2
0298: 2035     [27|32]  	jr nz, _cmd_mset_error
                        	; get second argument
029A: 212080   [37]     	ld hl, PTR_ARGV
029D: 3E01     [44]     	ld a, 1
029F: CDCC01   [61]     	call get_word_from_index
                        	; convert argument to word
02A2: CD7A03   [78]     	call word_to_val
02A5: 6069     [86]     	ld hl, bc
                        	; wait for data and copy to location
02A7:                   _cmd_mset_upper:
                        	; get first char
02A7: CDEB03   [17]     	call uart1_getch
02AA: CD9303   [34]     	call ch_to_upper
                        	; return on newline
02AD: FE0D     [41]     	cp 0x0D
02AF: 281A     [48|53]  	jr z, _cmd_mset_end
                        	; convert to 4 bits and shift
02B1: CD6C03   [65]     	call nibble_to_val
02B4: 0F       [69]     	rrca
02B5: 0F       [73]     	rrca
02B6: 0F       [77]     	rrca
02B7: 0F       [81]     	rrca
02B8: 47       [85]     	ld b, a
                        	; get lower nibble
02B9: CDEB03   [102]    	call uart1_getch
02BC: CD9303   [119]    	call ch_to_upper
                        	; return on newline
02BF: FE0D     [126]    	cp 0x0D
02C1: 2808     [133|138]	jr z, _cmd_mset_end
                        	; convert to 4 bits
02C3: CD6C03   [150]    	call nibble_to_val
02C6: B0       [154]    	or b
                        	; save to memory
02C7: 77       [161]    	ld (hl), a
                        	; next memory location
02C8: 23       [167]    	inc hl
02C9: 18DC     [179]    	jr _cmd_mset_upper
02CB:                   _cmd_mset_end:
02CB: CDF503   [17]     	call uart1_newline
02CE: C9       [27]     	ret
02CF:                   _cmd_mset_error:
02CF: C9       [10]     	ret
                        
                        
                        
                        ; command: jump to location
                        ;   argv in PTR_ARGV
                        ;   argc in PTR_ARGC
02D0:                   cmd_jump:
02D0: 3A3080   [13]     	ld a, (PTR_ARGC)
02D3: FE02     [20]     	cp 2
02D5: 200E     [27|32]  	jr nz, _cmd_jump_error
                        	; get second argument
02D7: 212080   [37]     	ld hl, PTR_ARGV
02DA: 3E01     [44]     	ld a, 1
02DC: CDCC01   [61]     	call get_word_from_index
                        	; convert argument to word
02DF: CD7A03   [78]     	call word_to_val
02E2: 6069     [86]     	ld hl, bc
                        	; jump to location
02E4: E9       [90]     	jp (hl)
02E5:                   _cmd_jump_error:
02E5: C9       [10]     	ret
                        
                        
                        
                        ; command: change upper ram page
02E6:                   cmd_page:
02E6: 3A3080   [13]     	ld a, (PTR_ARGC)
02E9: FE02     [20]     	cp 2
02EB: 20E2     [27|32]  	jr nz, _cmd_mset_error
                        	; get second argument
02ED: 212080   [37]     	ld hl, PTR_ARGV
02F0: 3E01     [44]     	ld a, 1
02F2: CDCC01   [61]     	call get_word_from_index
                        	; convert argument to word
02F5: CD7A03   [78]     	call word_to_val
02F8: 79       [82]     	ld a, c
                        	; write page id
02F9: D300     [93]     	out (PORT_MEMPAGE), a
02FB: C9       [103]    	ret
                        
                        
                        
                        ; command: load bytes to 0x0000
02FC:                   cmd_load:
                        	; switch upper 32k to page 0
02FC: 3E00     [ 7]     	ld a, 0x00
02FE: D300     [18]     	out (PORT_MEMPAGE), a
                        	; set stackpointer (since page was changed)
0300: 31FFFF   [28]     	ld sp, 0xFFFF
                        	; page 0 start address
0303: 210080   [38]     	ld hl, 0x8000
0306:                   _cmd_load_loop:
0306: CDEB03   [17]     	call uart1_getch
0309: FE0D     [24]     	cp 0x0D
030B: 2813     [31|36]  	jr z, _cmd_load_copy
                        	; not newline, convert to nibble
030D: CD6C03   [48]     	call nibble_to_val
0310: 0F       [52]     	rrca
0311: 0F       [56]     	rrca
0312: 0F       [60]     	rrca
0313: 0F       [64]     	rrca
0314: 47       [68]     	ld b, a
                        	; get lower nibble
0315: CDEB03   [85]     	call uart1_getch
0318: CD6C03   [102]    	call nibble_to_val
031B: B0       [106]    	or b
                        	; write data to ram
031C: 77       [113]    	ld (hl), a
031D: 23       [119]    	inc hl
031E: 18E6     [131]    	jr _cmd_load_loop
0320:                   _cmd_load_copy:
                        	; switch to upper ram page 1
0320: 3E01     [ 7]     	ld a, 0x01
0322: D300     [18]     	out (PORT_MEMPAGE), a
                        	; copy jump code
0324: 210705   [28]     	ld hl, jump_code
0327: 010080   [38]     	ld bc, 0x8000
032A: 160A     [45]     	ld d, jump_code_len
032C:                   _cmd_load_copy_loop:
032C: 7E       [ 7]     	ld a, (hl)
032D: 02       [14]     	ld (bc), a
032E: 23       [20]     	inc hl
032F: 03       [26]     	inc bc
0330: 15       [30]     	dec d
0331: 20F9     [37|42]  	jr nz, _cmd_load_copy_loop
                        	; everything ok
0333: 3E4B     [44]     	ld a, 'K'
0335: CDD403   [61]     	call uart1_putc
0338: CDF503   [78]     	call uart1_newline
                        	; code copied, jump to 0x8000
033B: C30080   [88]     	jp 0x8000
                        
                        
                        
                        ; dump_mem
                        ;   starting address in hl, dumps 256 bytes
033E:                   dump_mem:
033E: F5       [11]     	push af
033F: C5       [22]     	push bc
0340: 0600     [29]     	ld b, 0x00
0342:                   _dump_mem_loop:
                        	; check if newline needed
0342: 7D       [ 4]     	ld a, l
0343: E60F     [11]     	and 0x0F
0345: 2015     [18|23]  	jr nz, _dump_mem_1 ; skip newline
0347: CDF503   [35]     	call uart1_newline
                        	; print address
034A: 7C       [39]     	ld a, h
034B: CDAA03   [56]     	call print_byte
034E: 7D       [60]     	ld a, l
034F: CDAA03   [77]     	call print_byte
0352: 3E3A     [84]     	ld a, ':'
0354: CDD403   [101]    	call uart1_putc
0357: 3E20     [108]    	ld a, ' '
0359: CDD403   [125]    	call uart1_putc
035C:                   _dump_mem_1:
                        	; print byte
035C: 7E       [ 7]     	ld a, (hl)
035D: CDAA03   [24]     	call print_byte
0360: 3E20     [31]     	ld a, ' '
0362: CDD403   [48]     	call uart1_putc
                        	; address counter
0365: 23       [54]     	inc hl
                        	; byte counter
0366: 05       [58]     	dec b
0367: 20D9     [65|70]  	jr nz, _dump_mem_loop
0369: C1       [75]     	pop bc
036A: F1       [85]     	pop af
036B: C9       [95]     	ret
                        
                        
                        
                        ; nibble_to_val
                        ;   char in A, convert to hex number
036C:                   nibble_to_val:
036C: CD9303   [17]     	call ch_to_upper
036F: FE3A     [24]     	cp '9'+1
0371: 3802     [31|36]  	jr c, _nibble_to_val_1 ; jump if number 0-9
0373: D607     [38]     	sub 7                  ; sub for A-F
0375:                   _nibble_to_val_1:
0375: D630     [ 7]     	sub '0'
0377: E60F     [14]     	and 0x0F
0379: C9       [24]     	ret
                        
                        
                        
                        ; word_to_val
                        ;   pointer to string in hl
                        ;   returns word in bc
037A:                   word_to_val:
                        	; convert string to hex word
037A: 010000   [10]     	ld bc, 0
037D:                   _word_to_val_loop:
037D: 7E       [ 7]     	ld a, (hl)
037E: FE00     [14]     	cp 0
0380: C8       [19|25]  	ret z
0381: CD6C03   [36]     	call nibble_to_val
0384: E5       [47]     	push hl
                        	; shift left bc 4 times
0385: 6069     [55]     	ld hl, bc
0387: 29       [66]     	add hl, hl
0388: 29       [77]     	add hl, hl
0389: 29       [88]     	add hl, hl
038A: 29       [99]     	add hl, hl
038B: 85       [103]    	add a, l
038C: 6F       [107]    	ld l, a
038D: 444D     [115]    	ld bc, hl
                        	; advance pointer to next char
038F: E1       [125]    	pop hl
0390: 23       [131]    	inc hl
0391: 18EA     [143]    	jr _word_to_val_loop
                        
                        
                        
                        ; ch_to_upper
                        ;   char in A, convert to uppercase
0393:                   ch_to_upper:
                        	; less than 'a': return
0393: FE61     [ 7]     	cp 'a'
0395: D8       [12|18]  	ret c
                        	; greater than 'z': return
0396: FE7B     [19]     	cp 'z'+1
0398: D0       [24|30]  	ret nc
                        	; convert to upper case
0399: D620     [31]     	sub 0x20
039B: C9       [41]     	ret
                        
                        
                        
                        ; print_nibble
                        ;   byte in A, convert to char and print via uart
039C:                   print_nibble:
039C: E60F     [ 7]     	and 0x0F
039E: C630     [14]     	add a, '0'
03A0: FE3A     [21]     	cp '9'+1
03A2: 3802     [28|33]  	jr c, print_nibble_1
03A4: C607     [35]     	add a, 'A'-'0'-0xA
03A6:                   print_nibble_1:
03A6: CDD403   [17]     	call uart1_putc
03A9: C9       [27]     	ret
                        
                        
                        
                        ; print_byte
                        ;   byte in A
03AA:                   print_byte:
03AA: F5       [11]     	push af
03AB: 0F       [15]     	rrca
03AC: 0F       [19]     	rrca
03AD: 0F       [23]     	rrca
03AE: 0F       [27]     	rrca
03AF: CD9C03   [44]     	call print_nibble
03B2: F1       [54]     	pop af
03B3: CD9C03   [71]     	call print_nibble
03B6: C9       [81]     	ret
                        
                        
                        
                        ;   init uart port
03B7:                   uart_init:
                        	; UART1
                        	; LCR: Set DLAB Bit for Baud Rate
03B7: 3E80     [ 7]     	ld a, 0x80
03B9: D313     [18]     	out (PORT_UART1+3), a
                        	; Set Baud Rate
03BB: 3E0C     [25]     	ld a, 0x0c
03BD: D310     [36]     	out (PORT_UART1), a
03BF: 3E00     [43]     	ld a, 0x00
03C1: D311     [54]     	out (PORT_UART1+1), a
                        	; LCR: 8 bit, one stop, no parity, DLAB off
03C3: 3E03     [61]     	ld a, 0x03
03C5: D313     [72]     	out (PORT_UART1+3), a
                        	; No Interrupt
03C7: 3E00     [79]     	ld a, 0x00
03C9: D311     [90]     	out (PORT_UART1+1), a
                        	; FCR: FIFO off
03CB: 3E00     [97]     	ld a, 0x00
03CD: D312     [108]    	out (PORT_UART1+2), a
                        	; MCR: Deactivate all Pins
03CF: 3E00     [115]    	ld a, 0x00
03D1: D314     [126]    	out (PORT_UART1+4), a
                        	; return
03D3: C9       [136]    	ret
                        
                        
                        
                        ; uart1_putc
                        ;   sends a single char in a
03D4:                   uart1_putc:
03D4: F5       [11]     	push af
03D5:                   _uart1_putc_loop:
                        	; wait till ready
03D5: DB15     [11]     	in a, (PORT_UART1+5)
03D7: E640     [18]     	and 0x40
03D9: CAD503   [28|28]  	jp z, _uart1_putc_loop
                        	; ready to send char now
03DC: F1       [38]     	pop af
03DD: D310     [49]     	out (PORT_UART1), a
                        	; return from subroutine
03DF: C9       [59]     	ret
                        
                        
                        
                        ; uart1_puts
                        ;   sends a 0 terminated string. Pointer in hl.
03E0:                   uart1_puts:
03E0: 7E       [ 7]     	ld a, (hl)
03E1: F600     [14]     	or 0
03E3: C8       [19|25]  	ret z	; end of string? Yes: return
03E4: CDD403   [36]     	call uart1_putc
03E7: 23       [42]     	inc hl	; next character
03E8: C3E003   [52]     	jp uart1_puts
                        
                        
                        
                        ; uart1_getch
                        ;   waits until single character received. Character in a
03EB:                   uart1_getch:
03EB: DB15     [11]     	in a, (PORT_UART1+5)
03ED: E601     [18]     	and 0x01			; received char?
03EF: CAEB03   [28|28]  	jp z, uart1_getch   ; loop until a char is received
03F2: DB10     [39]     	in a, (PORT_UART1)	; get char
03F4: C9       [49]     	ret
                        
                        
                        
                        ; uart1_newline
                        ;   prints newline to terminal
03F5:                   uart1_newline:
03F5: F5       [11]     	push af
03F6: 3E0A     [18]     	ld a, 0x0A
03F8: CDD403   [35]     	call uart1_putc
03FB: 3E0D     [42]     	ld a, 0x0D
03FD: CDD403   [59]     	call uart1_putc
0400: F1       [69]     	pop af
0401: C9       [79]     	ret
                        
                        
                        
                        
                        
0402: 48656C6C          str_hello:	.db "Hello!", 0x0D, 0x0A, 0x00
0406: 6F210D0A          
040A: 00                
040B: 242000            str_promt:	.db "$ ",0
040E: 4572726F          str_error:	.db	"Error", 0x0D, 0x0A, 0x00
0412: 720D0A00          
                        
                        
0416: 24043A04          lst_cmds_str_ptr:	.dw lst_cmds_str_help,lst_cmds_str_dump,lst_cmds_str_mset,lst_cmds_str_jump,lst_cmds_str_page,lst_cmds_str_load,0x0000
041A: 6D049104          
041E: A804CB04          
0422: 0000              
0424: 68656C70          lst_cmds_str_help:	.db "help",0, "Prints this help",0
0428: 00507269          
042C: 6E747320          
0430: 74686973          
0434: 2068656C          
0438: 7000              
043A: 64756D70          lst_cmds_str_dump:	.db "dump",0, "Dumps 256bytes starting at location specified",0
043E: 0044756D          
0442: 70732032          
0446: 35366279          
044A: 74657320          
044E: 73746172          
0452: 74696E67          
0456: 20617420          
045A: 6C6F6361          
045E: 74696F6E          
0462: 20737065          
0466: 63696669          
046A: 656400            
046D: 6D736574          lst_cmds_str_mset:	.db "mset",0, "Write bytes to memory location",0
0471: 00577269          
0475: 74652062          
0479: 79746573          
047D: 20746F20          
0481: 6D656D6F          
0485: 7279206C          
0489: 6F636174          
048D: 696F6E00          
0491: 6A756D70          lst_cmds_str_jump:	.db "jump",0, "Jumps to location",0
0495: 004A756D          
0499: 70732074          
049D: 6F206C6F          
04A1: 63617469          
04A5: 6F6E00            
04A8: 70616765          lst_cmds_str_page:	.db "page",0, "Changes upper 32k memory page",0
04AC: 00436861          
04B0: 6E676573          
04B4: 20757070          
04B8: 65722033          
04BC: 326B206D          
04C0: 656D6F72          
04C4: 79207061          
04C8: 676500            
04CB: 6C6F6164          lst_cmds_str_load:	.db "load",0, "Writes bytes to page 0 and jumps to 0x0000",0
04CF: 00577269          
04D3: 74657320          
04D7: 62797465          
04DB: 7320746F          
04DF: 20706167          
04E3: 65203020          
04E7: 616E6420          
04EB: 6A756D70          
04EF: 7320746F          
04F3: 20307830          
04F7: 30303000          
                        
04FB: F6012D02          lst_cmds_ptr: .dw cmd_help, cmd_dump, cmd_mset, cmd_jump, cmd_page, cmd_load
04FF: 9302D002          
0503: E602FC02          
                        
                        
0507: 31FFFF3E          jump_code:		.db	0x31,0xFF,0xFF,0x3E,0x11,0xD3,0x00,0xC3,0x00,0x00
050B: 11D300C3          
050F: 0000              
000A:                   jump_code_len:	.equ 10


; +++ segments +++

#CODE          = $0000 =     0,  size = $0511 =  1297

; +++ global symbols +++

PORT_MEMPAGE         = $0000 =     0          monitor.asm:2
PORT_UART1           = $0010 =    16          monitor.asm:3
PORT_UART2           = $0018 =    24          monitor.asm:4 (unused)
PTR_ARGC             = $8030 = 32816          monitor.asm:8
PTR_ARGV             = $8020 = 32800          monitor.asm:7
PTR_INPUT            = $8000 = 32768          monitor.asm:6
_cmd_dump_error      = $0248 =   584          monitor.asm:320
_cmd_help_loop       = $01FE =   510          monitor.asm:276
_cmd_jump_error      = $02E5 =   741          monitor.asm:395
_cmd_load_copy       = $0320 =   800          monitor.asm:446
_cmd_load_copy_loop  = $032C =   812          monitor.asm:454
_cmd_load_loop       = $0306 =   774          monitor.asm:427
_cmd_mset_end        = $02CB =   715          monitor.asm:371
_cmd_mset_error      = $02CF =   719          monitor.asm:374
_cmd_mset_upper      = $02A7 =   679          monitor.asm:343
_dump_mem_1          = $035C =   860          monitor.asm:491
_dump_mem_loop       = $0342 =   834          monitor.asm:476
_end                 = $0511 =  1297          monitor.asm:11 (unused)
_get_index_found     = $01C6 =   454          monitor.asm:202
_get_index_list_loop = $01AA =   426          monitor.asm:179
_get_index_not_found = $01C8 =   456          monitor.asm:205
_handle_cmd_call_func = $0195 =   405          monitor.asm:153
_handle_cmd_error    = $019E =   414          monitor.asm:163
_init_loop           = $0010 =    16          monitor.asm:27
_main_loop           = $0106 =   262          monitor.asm:43
_main_loop_backspace = $0134 =   308          monitor.asm:79
_main_loop_getc      = $0116 =   278          monitor.asm:54
_main_loop_no_space  = $012C =   300          monitor.asm:71
_main_newline        = $014D =   333          monitor.asm:95
_nibble_to_val_1     = $0375 =   885          monitor.asm:515
_size                = $0511 =  1297          monitor.asm:11 (unused)
_strcmp_equal        = $01F3 =   499          monitor.asm:264
_strcmp_not_equal    = $01F0 =   496          monitor.asm:261
_uart1_putc_loop     = $03D5 =   981          monitor.asm:626
_word_to_val_loop    = $037D =   893          monitor.asm:528
_z80_                = $0001 =     1          monitor.asm:1 (unused)
add_argv             = $015B =   347          monitor.asm:111
ch_to_upper          = $0393 =   915          monitor.asm:552
cmd_dump             = $022D =   557          monitor.asm:305
cmd_help             = $01F6 =   502          monitor.asm:271
cmd_jump             = $02D0 =   720          monitor.asm:382
cmd_load             = $02FC =   764          monitor.asm:419
cmd_mset             = $0293 =   659          monitor.asm:331
cmd_page             = $02E6 =   742          monitor.asm:401
dump_mem             = $033E =   830          monitor.asm:472
get_index            = $01A5 =   421          monitor.asm:174
get_word_from_index  = $01CC =   460          monitor.asm:216
handle_cmd           = $0177 =   375          monitor.asm:136
init                 = $0000 =     0          monitor.asm:12 (unused)
jump_code            = $0507 =  1287          monitor.asm:693
jump_code_len        = $000A =    10          monitor.asm:694
lst_cmds_ptr         = $04FB =  1275          monitor.asm:690
lst_cmds_str_dump    = $043A =  1082          monitor.asm:684
lst_cmds_str_help    = $0424 =  1060          monitor.asm:683
lst_cmds_str_jump    = $0491 =  1169          monitor.asm:686
lst_cmds_str_load    = $04CB =  1227          monitor.asm:688
lst_cmds_str_mset    = $046D =  1133          monitor.asm:685
lst_cmds_str_page    = $04A8 =  1192          monitor.asm:687
lst_cmds_str_ptr     = $0416 =  1046          monitor.asm:682
main                 = $0100 =   256          monitor.asm:40
nibble_to_val        = $036C =   876          monitor.asm:510
print_byte           = $03AA =   938          monitor.asm:581
print_nibble         = $039C =   924          monitor.asm:567
print_nibble_1       = $03A6 =   934          monitor.asm:573
str_cmd_dump_help    = $024F =   591          monitor.asm:324
str_cmd_help         = $0221 =   545          monitor.asm:298
str_error            = $040E =  1038          monitor.asm:679
str_hello            = $0402 =  1026          monitor.asm:677
str_promt            = $040B =  1035          monitor.asm:678
strcmp               = $01DF =   479          monitor.asm:245
uart1_getch          = $03EB =  1003          monitor.asm:653
uart1_newline        = $03F5 =  1013          monitor.asm:664
uart1_putc           = $03D4 =   980          monitor.asm:624
uart1_puts           = $03E0 =   992          monitor.asm:641
uart_init            = $03B7 =   951          monitor.asm:595
word_to_val          = $037A =   890          monitor.asm:525


total time: 0.0131 sec.
no errors
